%% python-cs.tex
%
% Copyright 2018  Rudy Matela
%
% This text is available under (at your option):
%   * Creative Commons Attribution-ShareAlike 3.0 Licence
%   * GNU Free Documentation License version 1.3 or Later
%


\documentclass{refcard}
\usepackage[T1]{fontenc} % necessary so '{', '}' and '\' get the right font

\renewcommand{\familydefault}{\sfdefault}

\title{Concise Python Cheat Sheet}

\cright{
	Copyright 2018, Rudy Matela --
	Compiled on \today{} \\
	Upstream: \texttt{https://github.com/rudymatela/concise-cheat-sheets}
}{
	This text is available under
	the Creative Commons Attribution-ShareAlike 3.0 Licence, \\
	\textbf{or} (at your option), the GNU Free Documentation License version 1.3 or Later.
}
\version{0.0.0}


\begin{document}

\maketitle

\vspace{4em}
\begin{center}
{\Large\textbf{NOTE:} this is a work in progress}
\end{center}
\vspace{4em}

\section{Structure}

\begin{verbatim}
#!/usr/bin/env python

def hello(who):
    print("Hello " + who + "!");

hello("world")
\end{verbatim}



\section{Literals}

\begin{ldesc}
	\li[String with escapes]    "Escape \textbackslash{}'double-quotes\textbackslash{}', not 'single'"
	\li[String with escapes]    'Escape \textbackslash{}'single-quotes\textbackslash{}', not "double"'
\end{ldesc}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[tuples, lists, dictionaries]          (...), [...], {...}
	\Li[attribute reference]                  .
	\Li[function call, indexing\&slicing]     \I{name}(\I{args}), \I{name}{[}\I{index}{]}
	\Li[exponentiation]                       **
	\Li[bitwise negation]                     \~{}
	\Li[unary identity, unary negation]       -, +
	\Li[multiplication\&repetition, division] *, /
	\li[integer division, integer remainder]  //, \%
	\li[matrix multiplication]                @
	\Li[addition \& concat, subtraction]      +, -
	\Li[left shift, right shift]              <<, >>
	\Li[bitwise and]                          \&
	\Li[bitwise xor]                          \^{}
	\Li[bitwise or]                           |
	\Li[comparisons (chaining)]               ==, !=, <, <=, >, >=
	\li[object identity, set membership]      is, is not, in, not in
	\Li[logical negation]                     not
	\Li[conjunction]                          and
	\Li[disjunction]                          or
	\Li[ternary selection]                    \I{expr1} if \I{expr2} else \I{expr3}
	\Li[lambda]                               lambda \I{args}: \I{expr}
\end{Ldesc}


\section{Control Flow}

\begin{ldesc}
	\li[if statement]            if \I{condition}: \li
	                             ~~~~\I{code-block} \li

	\li[if-else statement]       if \I{condition1}: \li
	                             ~~~~\I{code-block} \li
								 else: \li
								 ~~~~\I{code-block} \li

	\li[if-elif-else statement]  if \I{condition1}: \li
	                             ~~~~\I{code-block} \li
								 elif \I{condition2}: \li
								 ~~~~\I{code-block} \li
								 else: \li
								 ~~~~\I{code-block} \li

	\li[while statement]         while \I{condition}: \li
	                             ~~~~\I{code-block} \li

	\li[for statement]           for \I{v} in \I{values}: \li
	                             ~~~~\I{code-block} \li

	\li[for statement (copy)]    for \I{v} in values[:]: \li
	                             ~~~~\I{code-block} \li

	\li[for statement (count)]   for \I{i} in range(\I{n}): \li
	                             ~~~~\I{code-block} ~~ \# from 0 to n \li

	\li[break statement]
		\I{while-or-for-statement}: \li
		~~~~break ~~ \# exit loop, skip else \li
		else: \li
		~~~~\I{code-block} \li

	\li[continue-statement]
		\I{while-or-for-statement}: \li
		~~~~continue ~~ \# next loop iteraction \li

	\li[pass-statement (no-op)]
		\I{def do-nothing():} \li
		~~~~pass \li

	\li[case/switch statements]  \textnormal{There aren't any.}
\end{ldesc}


\section{Functions}

\begin{ldesc}
	\li[referencing] \I{fun} \li

	\li[calling]     \I{fun}() \li

	\li[calling (w/arg)] \I{fun}(\I{arg\_value}) \li

	\li[calling (w/kw arg)] \I{fun}(\I{1st\_arg}, \I{2nd\_arg}, \I{key}=\I{val}) \li

	\li[0-arguments] def \I{fun}(): \li
	                 ~~~~\I{code-block} \li

	\li[1-argument]  def \I{fun}(\I{arg}): \li
	                 ~~~~\I{code-block} \li

	\li[2-arguments] def \I{fun}(\I{arg0},\I{arg1}): \li
	                 ~~~~\I{code-block} \li

	\li[default args] def \I{fun}(\I{mandatory},\I{optional}=\I{default\_val}): \li
	                       ~~~~\I{code-block} \li

	\li[arbitrary args] def \I{fun}(\I{mandatory}, \I{*args}): \li
	                         ~~~~\I{code-block} \li

	\li[lambda (1-arg)]      lambda \I{arg}:~\I{expression} \li

	\li[lambda (2-args)]     lambda \I{arg0},\I{arg1}:~\I{expression} \li

	\li[docstring] def \I{fun}(\I{args}): \li
	               ~~~~"""Concise summary of purpose \li
	               ~~~~ \li
	               ~~~~Longer description, if needed \li
	               ~~~~""" \li
	               ~~~~\I{code-block} \li
\end{ldesc}

\section{Evaluation Order}

Expressions are evaluated left-to-right:
\begin{verbatim}
1st + (2nd * 3rd)
(1st + 2nd) * 3rd
3rd + 4th = 1st, 2nd
\end{verbatim}

\section{List Comprehensions}

Take \emph{element} from \emph{list}.
If \emph{boolPredicate}, add element \emph{expr} to list:\\
\begin{tabular}{C@{\s$\equiv$\s}C}
	\multicolumn{2}{C}{[\I{expr} for \I{element} in \I{list} if \I{boolPredicate} ...]} \\[1ex]
	{[}x for x in \I{xs}]                   & \I{xs} \\
	{[}\I{f} x for x in \I{xs} if \I{p} x]    & list(map(\I{f},filter(\I{p},\I{xs}))) \\
	{[}x for x in \I{xs} if \I{p} x if \I{q} x] & list(filter(\I{q},filter(\I{p},\I{xs}))) \\
\multicolumn{2}{C}{
	{[}x+y for x in [\I{a},\I{b}] for y in [\I{i},\I{j}]] $\equiv$
	    [\I{a}+\I{i}, \I{a}+\I{j}, \I{b}+\I{i}, \I{b}+\I{j}]
} \\
\end{tabular}

\section{Functions}

\subsection{Lists}

\begin{ldesc}
	\li[append \C{x} to the end of list \C{xs}]                xs.append(x)
	\li[append iterable \C{iter} to the end of list \C{xs}]    xs.extend(iter)
	\li[insert \C{x} in position \C{i} on the list \C{xs}]     xs.insert(i, x)
	\li[remove the first occurrence of \C{x} in \C{xs}]        xs.remove(x)
	\li[remove then return the last element of xs]             xs.pop()
	\li[remove then return the \C{i}-th element of xs]         xs.pop(i)
	\li[remove all items from \C{xs}]                          xs.clear()
	\li[index of the first occurrence of \C{x}]                xs.index(x)
	\li[~~~~ between \C{i} and \C{j}]                          xs.index(x,i,j)
	\li[count occurrences of \C{x} in \C{xs}]                  xs.count(x)
	\li[sort the list \C{xs}]                                  xs.sort()
	\li[sort the list \C{xs} in reverse]                       xs.sort(reverse=True)
	\li[sort the list \C{xs} using keying function \C{k}]      xs.sort(key=k)
	\li[reverse the list \C{xs}]                               xs.reverse()
	\li[return a copy of the list \C{xs}]                      xs.copy()
\end{ldesc}

\subsection{Objects}

\begin{ldesc}
	\li[list attributes \& methods of an object] dir(o)
\end{ldesc}

\section{Modules}

\begin{ldesc}
	\li[qualified module import] import \I{module} \li
	                             module.foo() \li
	\li[unqualified module import] from \I{module} import * \li
	                               foo() \li
	\li[import specific name]      from \I{module} import \I{foo} \li
	                               foo() \li
	\li[import module renaming] import \I{module} as \I{m} \li
	                            m.foo() \li
	\li[import specific rename] from \I{module} import \I{foo} as \I{f} \li
	                            f()
\end{ldesc}


\section{String Methods}

\begin{ldesc}
	\li[String formatting operation] str.format(args)
\end{ldesc}


\section{IO}

\subsection{Printing}

\begin{ldesc}
	\li[printable representation of \I{x}]          str(x)
	\li[parsable printable representation of \I{x}] repr(x)
	\li[identity of \I{x}]                          parse(repr(x))
\end{ldesc}


\section{String formatting}

\begin{ldesc}
	\li[format \I{x} to string using \C{str}] "\{0\}".format(x)
	\li[format \I{x} to decimal]     "\{0:d\}".format(x)
	\li[format \I{x} to hexadecimal] "\{0:x\}".format(x)
	\li[format \I{x} to octal]       "\{0:o\}".format(x)
	\li[replace \C{\{0\}} by \I{s}] "...~\{0\}~...".format(s)
	\li[repl.~\C{\{0\}} and \C{\{1\}} by \I{s0} and \I{s1}]  ".~\{0\}~.~\{1\}~." \% (s0,s1)
	\li[generate \C{"pi is 3.14"}]    "pi is \{0:2f\}".format(math.pi)
	\li[generate \C{"pi is 003.141"}] "pi is \{0:3.3f\}".format(math.pi)
\end{ldesc}


\section{Old printf-style string formatting}

\begin{ldesc}
	\li[format \I{x} to string using \C{str}] "\%s" \% x
	\li[format \I{x} to string using \C{repr}] "\%s" \% x
	\li[format \I{x} to decimal]     "\%d" \% x
	\li[format \I{x} to hexadecimal] "\%x" \% x
	\li[format \I{x} to octal]       "\%o" \% x
	\li[replace \C{\%s} by \I{s}] "...~\%s~..." \% s
	\li[repl.~\C{\%s} by \I{s1} then \I{s2}]  ".~\%s~.~\%s~." \% (s1,s2)
	\li[generate \C{"pi is 3.14"}] "pi is \%.2f" \% math.pi
	\li[generate \C{"pi is 003.141"}] "pi is \%3.3f" \% math.pi
	\li[generate \C{"1 + 1 = 2"}] "1 + 1 = \%d" \% (1 + 1)
	\li[generate \C{"2'n'1"}] "\%(two)d'n'\%(one)d" \% \{'one':~1, \li
	                              ~~~~~~~~~~~~~~~~~~~~~~ "two":~2\}
\end{ldesc}



\end{document}
